<?php

/**
 * File System monitor | FSMon
 * @version 1.0.1
 * @author j4ck <rustyj4ck@gmail.com>
 * @link https://github.com/rustyJ4ck/FSMon
 */

$root_dir = $this_dir = dirname(__FILE__) . DIRECTORY_SEPARATOR;

// read config

$config = @include($this_dir . 'config.php');

if (isset($config['root'])) {
    $root_dir = $config['root'];
}

$files_preg = @$config['files'];

// server name

$SERVER_NAME = @$config['server'] ? $config['server'] : @$_SERVER['SERVER_NAME'];
$SERVER_NAME = $SERVER_NAME ? $SERVER_NAME : 'localhost';

$precache = $cache = array();

console::start();

// read cache

$cache_file = $this_dir . '.cache';

if (file_exists($cache_file)) {
    $precache = $cache = unserialize(file_get_contents($cache_file));
}

// scan 

$result = array();

$checked_ids = array();

$tree = array();
fs::build_tree($root_dir, $tree, false, $files_preg);

$files = $tree['files'];

foreach ($files as $f) {

    console::log("...%s", $f);

    $id = fs::file_id($f);

    $checked_ids [] = $id;

    if (isset($cache[$id])) {
        // present

        $csumm = fs::crc_file($f);
        if ($cache[$id]['crc'] != $csumm) {
            // modded
            $cache[$id]['crc']  = $csumm;
            $cache[$id]['file'] = $f;
            $result[]           = array('file' => $f, 'result' => 'modified');
        } else {
            // old one
        }
    } else {
        // new
        $csumm              = fs::crc_file($f);
        $cache[$id]['crc']  = $csumm;
        $cache[$id]['file'] = $f;
        $result[]           = array('file' => $f, 'result' => 'new');
    }

}

// check for deleted files

$deleted = !empty($precache) ? array_diff(array_keys($precache), $checked_ids) : false;

if (!empty($deleted)) {
    foreach ($deleted as $id) {
        $result[] = array('file' => $precache[$id]['file'], 'result' => 'deleted');
        unset($cache[$id]);
    }
}

//
// Changes detected
//

if (!empty($result)) {
    $buffer = '';

    console::log('Reporting...');

    foreach ($result as $r) {

        $line = sprintf("[%10s]\t%s\t%s kb\t%s"
            , $r['result']
            , $r['file']
            , @round(filesize($r['file']) / 1024, 1)
            , @date('d.m.Y H:i', filemtime($r['file']))
        );

        console::log($line);

        $buffer .= $line;
        $buffer .= PHP_EOL;
    }

    // mail
    if (@$config['mail']['enable']) {

        $from = @$config['mail']['from'] ? $config['mail']['from'] : 'root@localhost';
        $to   = @$config['mail']['to'] ? $config['mail']['to'] : 'root@localhost';

        if ($to === 'root@localhost') {
            echo "Empty mail@to";
        } else {

            $subject = "FSMon report for " . $SERVER_NAME;
            $buffer .= "\n\nGenerated by FSMon | " . date('d.m.Y H:i') . '.';

            console::log('Message to %s', $to);

            mailer::send(
                $from, $to, $subject, $buffer
            );
        }
    }
} else {
    console::log('All clear');
}

//
// save result
//

file_put_contents(
    $cache_file
    , serialize($cache)
);

console::log('Done');

//
// Done
//

class console {

    private static $time;

    static function start() {
        self::$time = microtime(1);
    }

    static function log() {
        $args   = func_get_args();
        $format = array_shift($args);
        $format = '%.5f| ' . $format;
        array_unshift($args, self::time());
        echo vsprintf($format, $args);
        echo PHP_EOL;
    }

    private static function time() {
        return microtime(1) - self::$time;
    }
}

/**
 * Mail helper
 */
class mailer {

    static function send($from, $to, $subject, $message) {

        $headers = 'From: ' . $from . "\r\n" .
            'Reply-To: ' . $from . "\r\n" .
            'X-Mailer: PHP/fsmon';

        return mail($to, $subject, $message, $headers);
    }

}

/**
 * FileSystem helpers
 */
class fs {

    /**
     * Find files
     */
    public static function scan_dir_for_files($o_dir, $files_preg = '') {
        $ret = array();
        $dir = @opendir($o_dir);
        while (false !== ($file = @readdir($dir))) {
            $path = $o_dir . /*DIRECTORY_SEPARATOR .*/
                $file;
            if (!is_dir($path) && $file != '..' && $file != '.'
                && (empty($files_preg) || (!empty($files_preg) && preg_match("#{$files_preg}#", $file)))
            ) {
                $ret [] = $path;
            }
        }
        @closedir($dir);

        return $ret;
    }

    /**
     * Scan dirs. One level
     */
    public static function scan_dir_for_dirs($o_dir) {

        $ret = array();
        $dir = @opendir($o_dir);

        while (false !== ($file = @readdir($dir))) {
            $path = $o_dir /*. DIRECTORY_SEPARATOR*/ . $file;
            if (is_dir($path) && $file != '..' && $file != '.') {
                $ret [] = $path;
            }
        }

        @closedir($dir);

        return $ret;
    }

    /**
     * Build tree
     *
     * @desc build tree
     * @param string root
     * @param array &buffer
     * @param array dir filters
     * @param string file regex filter
     * @return array['files' = [...], 'dirs' = [...]]
     */
    public static function build_tree($root_path, array &$data, $dirs_filter = array(), $files_preg = '.*') {

        if (substr($root_path, -1, 1) != DIRECTORY_SEPARATOR) $root_path .= DIRECTORY_SEPARATOR;

        $dirs  = self::scan_dir_for_dirs($root_path);
        $files = self::scan_dir_for_files($root_path, $files_preg);

        if (empty($data)) {
            $data['files'] = array();
            $data['dirs']  = array();
        }

        $data['dirs'][] = $root_path;
        $data['files']  = array_merge($data['files'], $files);

        foreach ($dirs as $dir) {
            // check filters
            if (empty($dirs_filter) || !in_array(preg_replace('/^.*\/(.*)$/', '\1', $dir), $dirs_filter))
                self::build_tree($dir, $data, $dirs_filter, $files_preg);
        }
    }


    /**
     * unique file name
     */
    public static function file_id($path) {
        return md5($path);
    }

    /**
     * Checksum
     */
    public static function crc_file($path) {
        return sprintf("%u", crc32(file_get_contents($path)));
    }
}

